# This file has been automatically generated by PreprocessInputs.jl. Any user inputs might be overwritten!




@doc raw"""
    Fsys_agg(X, XPrime, Xss, distrSS, m_par, n_par, indexes)

Return deviations from aggregate equilibrium conditions.

`indexes` can be both `IndexStruct` or `IndexStructAggr`; in the latter case
(which is how function is called by [`SGU_estim()`](@ref)), variable-vectors
`X`,`XPrime`, and `Xss` only contain the aggregate variables of the model.
"""
function Fsys_agg(X::AbstractArray, XPrime::AbstractArray, Xss::Array{Float64,1},distrSS::AbstractArray, m_par::ModelParameters,
              n_par::NumericalParameters, indexes::Union{IndexStructAggr,IndexStruct})
              # The function call with Duals takes
              # Reserve space for error terms
    F = zeros(eltype(X),size(X))
    ############################################################################
    #            I. Read out argument values                                   #
    ############################################################################

    ############################################################################
    # I.1. Generate code that reads aggregate states/controls
    #      from steady state deviations. Equations take the form of:
    # r       = exp.(Xss[indexes.rSS] .+ X[indexes.r])
    # rPrime  = exp.(Xss[indexes.rSS] .+ XPrime[indexes.r])
    ############################################################################

    # @generate_equations(aggr_names)
    @generate_equations()

    # Take aggregate model from model file


#------------------------------------------------------------------------------
# THIS FILE CONTAINS THE "AGGREGATE" MODEL EQUATIONS, I.E. EVERYTHING  BUT THE 
# HOUSEHOLD PLANNING PROBLEM. THE lATTER IS DESCRIBED BY ONE EGM BACKWARD STEP AND 
# ONE FORWARD ITERATION OF THE DISTRIBUTION.
#
# AGGREGATE EQUATIONS TAKE THE FORM 
# F[EQUATION NUMBER] = lhs - rhs
#
# EQUATION NUMBERS ARE GENEREATED AUTOMATICALLY AND STORED IN THE INDEX STRUCT
# FOR THIS THE "CORRESPONDING" VARIABLE NEEDS TO BE IN THE LIST OF STATES 
# OR CONTROLS.
#------------------------------------------------------------------------------



############################################################################
#           Error term calculations (i.e. model starts here)          #
############################################################################

# Shocks
F[indexes.Z]            = log.(ZPrime)  - m_par.ρ_Z * log.(Z)               # TFP

# Prices
F[indexes.r]       = log.(r) - log.(interest(K, Z, N, m_par) + 1.0 )       # rate of return on capital
F[indexes.w]       = log.(w) - log.(wage(K, Z, N, m_par))     # wages that firms pay

# Aggregate Quantities
F[indexes.I]            = KPrime .-  K .* (1.0 .- m_par.δ_0) .- I          # Capital accumulation equation
F[indexes.N]            = log.(N) - log.(w.^(1.0 / m_par.γ))   # labor supply
F[indexes.Y]            = log.(Y) - log.(Z .* N .^(1.0 .- m_par.α) .* K .^m_par.α)                                          # production function
F[indexes.C]            = log.(Y .- I) .- log(C)                            # Resource constraint

# Capital market clearing
F[indexes.K]            = log.(K)     - (Xss[indexes.KSS])                   


# Lags
F[indexes.Ilag]         = log(IlagPrime)    - log(I)
F[indexes.wlag]         = log(wlagPrime)    - log(w)
F[indexes.Nlag]         = log(NlagPrime)    - log(N)
F[indexes.Clag]         = log(ClagPrime)    - log(C)
  
# Growth rates
F[indexes.Ngrowth]      = log(Ngrowth)      - log(N/Nlag)
F[indexes.Igrowth]      = log(Igrowth)      - log(I/Ilag)
F[indexes.wgrowth]      = log(wgrowth)      - log(w/wlag)
F[indexes.Cgrowth]      = log(Cgrowth)      - log(C/Clag)
    

    # @include "../3_Model/input_aggregate_model.jl"

    return F
end


